/*
El parcial consta de 4 puntos, 1 teórico y 3 prácticos.

1-Teórico: Sobre un TDA se pide, definición, interface, precondiciones, 
implementación dinámica de un método en Java (que agregue elemento a la lista), 
gráficos para las operaciones básicas,  análisis de costo de todos los métodos. 
Preferentemente poner foco en los siguientes TDAs para este punto: Pila, Cola, 
Conjunto y Diccionario Simple.

Prácticos:

2-Un ejercicio de AVL similar a los vistos en clase, aplicación de rotaciones.
3-Un ejercicio de AB: Operaciones de inserción (división) y eliminación (donación y fusión)
4- Similar a los siguientes ejercicios de la guía:
	TP1: 4e, 4f
	TP3:1a, 1b, 1d. 2a, 2.c. 3.Todos, 4, 5.1a,b y c, 5.2
	TP4: 3. de a) hasta l) 
*/

/* Pila */
public interface PilaTDA {
	void InicializarPila();
	void Apilar( int x);
	void Desapilar();
	boolean PilaVacia();
	int Tope ();
}
public class PilaLD implements PilaTDA{
	Nodo primero;
	public void InicializarPila(){
		primero = null ;
	}
	public void Apilar( int x){
		Nodo aux = new Nodo ();
		aux .info = x;
		aux .sig = primero;
		primero = aux;
	}
	public void Desapilar(){
		primero = primero.sig;
	}
	public boolean PilaVacia(){
		return ( primero == nul l );
	}
	public int Tope (){
		return primero. info ;
	}
}

/* Cola */
public inter face ColaTDA {
	void InicializarCola();
	void Acolar( int x);
	void Desacolar();
	boolean ColaVacia();
	int Primero();
}
public class ColaLD implements ColaTDA{
	Nodo primero;
	Nodo ultimo;
	public void InicializarCola(){
		primero = null ;
		ultimo = null ;
	}
	public void Acolar( int x){
		Nodo aux = new Nodo ();
		aux .info = x;
		aux .sig = nul l ;
		if ( ultimo != nul l )
			ultimo.sig = aux;
			ultimo = aux;
		if( primero == nul l )
			primero = ultimo;
	}
	public void Desacolar(){
		primero = primero.sig;
		if ( primero == nul l )
			ultimo = nul l ;
	}
	public boolean ColaVacia(){
		return ( ultimo == nul l );
	}
	public int Primero(){
		return primero. info ;
	}
}
/* Conjuntos */
public interface ConjuntoTDA {
	void InicializarConjunto ();
	boolean ConjuntoVacio();
	void Agregar( int x);
	int Elegir();
	void Sacar( int x);
	boolean Pertenece( int x);
}
public class ConjuntoLD implements ConjuntoTDA {
	Nodo c;	
	public void InicializarConjunto () {
		c = null ;
	}
	public boolean ConjuntoVacio() {
		return (c == nul l );
	}
	public void Agregar( int x) {
		if (!this.Pertenece(x)){
			Nodo aux = new Nodo ();
			aux. info = x;
			aux.sig = c;
			c = aux ;
		}
	}
	public int Elegir() {
		return c.info ;
	}
	public void Sacar( int x) {
		if (c!= null){
			if (c.info == x) {
			c = c.sig ;
		} else {
			Nodo aux = c;
			while (aux.sig != null && aux.sig.info !=x)
				aux = aux.sig;
				if (aux.sig != null )
					aux.sig = aux.sig.sig;
			}
		}
	}
	public boolean Pertenece( int x) {
		Nodo aux = c;
		while ((aux != null ) && (aux. info != x)){
			aux = aux.sig;
		}
		return (aux != null );
	}
}
/* Diccionario Simple */
public class DicSimpleL implements DiccionarioSimpleTDA {
	class NodoClave{
		int clave;
		int valor;
		NodoClave sigClave;
	}
	NodoClave origen;
	public void InicializarDiccionario (){
		origen = null;
	}
	public void Agregar( int clave , int valor){
		NodoClave nc = Clave2NodoClave( clave);
		if(nc == null) {
			nc = new NodoClave();
			nc.clave = clave;
			nc.sigClave = origen;
			origen = nc;
		}
		nc.valor = valor;
	}
	private NodoClave Clave2NodoClave( int clave){
		NodoClave aux = origen;
		while (aux != null && aux.clave!= clave){
			aux = aux.sigClave;
		}
		return aux ;
	}
	public void Eliminar( int clave) {
		if( origen!= null) {
			if(origen.clave == clave) {
				origen = origen.sigClave;
			} else {
				NodoClave aux = origen;
				while(aux.sigClave != null && aux.sigClave.clave!= clave){
					aux = aux.sigClave;
				}
				if( aux. sigClave!= nul l ) {
					aux.sigClave= aux.sigClave.sigClave;
				}
			}
		}
	}
	public int Recuperar( int clave){
		NodoClave n = Clave2NodoClave( clave);
		return n.valor;
	}
	public ConjuntoTDA Claves(){
		ConjuntoTDA c = new ConjuntoLD();
		c.InicializarConjunto ();
		NodoClave aux = origen;
		while(aux != null){
			c.Agregar(aux.clave);
			aux = aux.sigClave;
		}
		return c;
	}
}
